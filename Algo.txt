Character Count'

#include <stdio.h>
#include <string.h>

int main() {
    char msg[100];
    printf("Enter the msg: ");
    scanf("%s", msg);
    int n = strlen(msg), fcnt;
    printf("Enter the no.of frames: ");
    scanf("%d", &fcnt);
    int c = 0; 
    int fd[fcnt];
    for(int i=0;i<fcnt;i++){
        printf("Enter the size of frame %d: ", i + 1);
        scanf("%d",&fd[i]);
    }
    for (int i = 0; i < fcnt; i++) {
        printf("Frame %d: ", i + 1);
        for (int j = 0; j < fd[i]; j++) {
            printf("%c", msg[c]);
            c++;
        }
        printf("\n");
    }

    return 0;
}

Selective Repeat

#include <stdio.h>
#include <stdlib.h>
void main(){
    int n;
    printf("Enter the frame size: ");
    scanf("%d",&n);
    int w;
    printf("Enter the window size: ");
    scanf("%d",&w);
    int ack[n];
    for(int i=0;i<n;i++){
        ack[i] = 0;
    }
    for(int i=0;i<n;i=i+w){
        for(int j=0;j<w && i+j<n;j++){
            printf("Sent %d\n",i+j);
        }
        for(int j=0;j<w && i+j<n;j++){
            int k;
            printf("Enter the acknowledgment of %d: ",i+j);
            scanf("%d",&k);
            if(k==1) ack[i+j]=1;
        }
        for(int j=0;j<w && i+j<n;j++){
            if(ack[i+j]==1){
                printf("Acknowledgment recieved for %d\n",i+j);
            }
        }
        for(int j=0;j<w && i+j<n;j++){
            while(ack[i+j]==0){
                printf("Sent %d again\n",i+j);
                int k;
                printf("Enter the acknowledgment of %d: ",i+j);
                scanf("%d",&k);
                if(k == 1){
                    ack[i+j] = 1;
                    printf("Acknowledgment recieved for %d\n",i+j);
                }
            }
        }
    }
    printf("successful\n");
}

Go Back N

#include <stdio.h>

int main() {
    int n, w;
    printf("Enter the frame size: ");
    scanf("%d", &n);
    printf("Enter the window size: ");
    scanf("%d", &w);
    for (int i = 0; i < n; ) {
        for (int j = i; j < i + w && j < n; j++) {
            printf("Frame sent for %d\n", j);
        }
        int ack;
        printf("Acknowledgement for frame %d: ", i);
        scanf("%d", &ack);
        if (ack == 1) {
            i++;
        } else {
            printf("Frame %d sending again\n", i);
        }
    }
    printf("successful\n");
    return 0;
}


Character stuffing

#include <stdio.h>
#include <string.h>

int main() {
    char str[100];
    printf("Enter the string:");
    scanf("%s",str);
    printf("The string is: %s\n",str);
    
    char sts[100]=""; //stuffed string
    strcat(sts, "DLESTX");
    
    int j=strlen(sts);
    int l=strlen(str);
    for(int i=0;i<l;i++){
        if(str[i]=='D' && str[i+1]=='L' && str[i+2]=='E'){
            strcat(sts, "DLE");
            strcat(sts, "DLE");
            i+=3;
            j+=6;
        }
        sts[j] = str[i];
        j++;
    }
    sts[j]='\0';
    strcat(sts, "DLEETX");
    printf("The stuffed string is: %s\n",sts);
    
    char dts[100]=""; //destuffed string
    int l2 =strlen(sts);
    j=0;
    for(int i=6;i<l2-6;i++){
        if(i+2 < l2){
            if(sts[i]=='D' && sts[i+1]=='L' && sts[i+2]=='E'){
                strcat(dts, "DLE");
                i+=6;
                j+=3;
                if(i>=l2-6)break;
            }
        }
        dts[j] = sts[i];
        j++;
    }
    dts[j] = '\0';
    printf("The destuffed string is: %s\n", dts);
    return 0;
}

Bit Stuffing

#include <stdio.h>
#include <string.h>

int main() {
    char s[1000];
    printf("Enter the original bit string: ");
    scanf("%s", s);

    int n = strlen(s);

    // Bit Stuffing
    char stuffed[2000];
    int count = 0, k = 0;

    for (int i = 0; i < n; i++) {
        stuffed[k++] = s[i];
        if (s[i] == '1') {
            count++;
            if (count == 5) {  // After 5 consecutive 1's, insert a '0'
                stuffed[k++] = '0';
                count = 0;
            }
        } else {
            count = 0;
        }
    }
    stuffed[k] = '\0';

    printf("Stuffed: %s\n", stuffed);

    // Bit De-stuffing
    char destuffed[1000];
    int j = 0;
    count = 0;

    for (int i = 0; i < strlen(stuffed); i++) {
        destuffed[j++] = stuffed[i];
        if (stuffed[i] == '1') {
            count++;
            if (count == 5 && stuffed[i + 1] == '0') {
                i++; // Skip the stuffed 0
                count = 0;
            }
        } else {
            count = 0;
        }
    }
    destuffed[j] = '\0';

    printf("Destuffed: %s\n", destuffed);

    return 0;
}

CRC

#include <stdio.h>
#include <string.h>

int main() {
    char gen[20], msg[1000], temp[1000];
    printf("Enter generating polynomial: ");
    scanf("%s", gen);
    int gl = strlen(gen);       // generator length
    int k = gl - 1;

    printf("Enter message: ");
    scanf("%s", msg);
    int ml = strlen(msg);       // message length

    // Append k zeros to the message
    char code[1000];
    strcpy(code, msg);
    for (int i = 0; i < k; i++) strcat(code, "0");

    printf("Codeword before division: %s\n", code);

    // Perform Division (XOR operation)
    strcpy(temp, code);
    for (int i = 0; i < ml; i++) {
        if (temp[i] == '1') {
            for (int j = 0; j < gl; j++) {
                temp[i + j] = (temp[i + j] == gen[j]) ? '0' : '1';
            }
        }
    }

    // Remainder is last k bits
    printf("Remainder: ");
    for (int i = ml; i < ml + k; i++) {
        printf("%c", temp[i]);
    }
    printf("\n");

    // Final transmitted codeword = original msg + remainder
    for (int i = ml; i < ml + k; i++) {
        code[i] = temp[i];
    }
    code[ml + k] = '\0';
    printf("Transmitted Codeword: %s\n", code);

    // Receiver side check
    strcpy(temp, code);
    for (int i = 0; i < ml; i++) {
        if (temp[i] == '1') {
            for (int j = 0; j < gl; j++) {
                temp[i + j] = (temp[i + j] == gen[j]) ? '0' : '1';
            }
        }
    }

    int error = 0;
    for (int i = ml; i < ml + k; i++) {
        if (temp[i] != '0') {
            error = 1;
            break;
        }
    }

    if (error)
        printf("Error detected during transmission!\n");
    else
        printf("Transmission successful! No error detected.\n");

    return 0;
}


Leaky Bucket

#include <stdio.h>
void lb1(){
    int n,t;
    printf("Enter no.of packets: ");
    scanf("%d",&n);
    printf("Enter time: ");
    scanf("%d",&t);
    for(int i=1;i<=t;i++){
        printf("Time %d\n",i);
        if(i==t){
            for(int j=1;j<=n;j++){
                printf("Packet %d sent\n",j);
            }
        }
    }
    printf("All packets sent successfully\n");
}
void lb2(){
    int n;
    printf("Enter no.of packets: ");
    scanf("%d",&n);
    for(int j=1;j<=n;j++){
        printf("Time %d ,Packet %d sent\n",j,j);
    }
    printf("All packets sent successfully\n");
    printf("outrate: %d\n",n);
}
void main(){
    int t;
    printf("Enter testcase: ");
    scanf("%d",&t);
    if(t==1) lb1();
    else lb2();
}




DVU

#include <stdio.h>

#define INF 999
#define MAX 10

int main() {
    int cost[MAX][MAX], dist[MAX][MAX], via[MAX][MAX];
    int n, i, j, k;

    printf("Enter the number of nodes: ");
    scanf("%d", &n);

    printf("Enter the cost matrix (use %d for no direct link):\n", INF);
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            scanf("%d", &cost[i][j]);
            if (i == j)
                cost[i][j] = 0;
        }
    }

    // Initialize distance and via matrices
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            dist[i][j] = cost[i][j];
            if (i != j && cost[i][j] != INF)
                via[i][j] = j;
            else
                via[i][j] = -1;
        }
    }

    // Distance Vector algorithm (Floyd–Warshall type update)
    for (k = 0; k < n; k++) {
        for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    via[i][j] = via[i][k];
                }
            }
        }
    }

    // Print routing tables
    for (i = 0; i < n; i++) {
        printf("\nRouting table for Node %d:\n", i);
        printf("Destination\tNext Hop\tCost\n");
        for (j = 0; j < n; j++) {
            if (i != j) {
                printf("%d\t\t", j);
                if (via[i][j] != -1)
                    printf("%d\t\t", via[i][j]);
                else
                    printf("-\t\t");
                printf("%d\n", dist[i][j]);
            }
        }
    }

    return 0;
}


Dijkstra's

#include <stdio.h>
#include <limits.h>

#define INF 100000

void printPath(int parent[], int j) {
    if (j == -1)
        return;
    printPath(parent, parent[j]);
    printf("%d ", j);
}

int main() {
    int n;
    printf("Enter the number of nodes: ");
    scanf("%d", &n);

    int a[n][n];
    printf("Enter the adjacency matrix (0 for no edge):\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &a[i][j]);
            if (i != j && a[i][j] == 0)
                a[i][j] = INF;
        }
    }

    int src, dest;
    printf("Enter source and destination (0-based indices): ");
    scanf("%d %d", &src, &dest);

    int dist[n], visited[n], parent[n];

    for (int i = 0; i < n; i++) {
        dist[i] = INF;
        visited[i] = 0;
        parent[i] = -1;
    }

    dist[src] = 0;

    // Dijkstra’s algorithm
    for (int count = 0; count < n - 1; count++) {
        int u = -1, min = INF;

        // Find the unvisited node with the smallest distance
        for (int i = 0; i < n; i++) {
            if (!visited[i] && dist[i] < min) {
                min = dist[i];
                u = i;
            }
        }

        if (u == -1)
            break; // no reachable remaining nodes

        visited[u] = 1;

        // Relaxation step
        for (int v = 0; v < n; v++) {
            if (!visited[v] && a[u][v] != INF && dist[u] + a[u][v] < dist[v]) {
                dist[v] = dist[u] + a[u][v];
                parent[v] = u;
            }
        }
    }

    if (dist[dest] == INF) {
        printf("No path exists from %d to %d\n", src, dest);
    } else {
        printf("\nShortest distance from %d to %d = %d\n", src, dest, dist[dest]);
        printf("Path: ");
        printPath(parent, dest);
        printf("\n");
    }

    return 0;
}


OTP:

#include <stdio.h>
#include <string.h>
int main() {
    char text[100], key[100], enc[100], dec[100];
    int i;
    printf("Enter plaintext (lowercase letters only): ");
    scanf("%s", text);
    printf("Enter key (same length as text): ");
    scanf("%s", key);
    int len = strlen(text);
    for (i = 0; i < len; i++) {
        enc[i] = ((text[i] - 'a') + (key[i] - 'a')) % 26 + 'a';
    }
    enc[i] = '\0';
    printf("Encrypted text: %s\n", enc);
    for (i = 0; i < len; i++) {
        dec[i] = ((enc[i] - 'a') - (key[i] - 'a') + 26) % 26 + 'a';
    }
    dec[i] = '\0';
    printf("Decrypted text: %s\n", dec);
    return 0;
}
OUTPUT
Enter plaintext (lowercase letters only): hello
Enter key (same length as text): 5
Encrypted text: VRSPT
Decrypted text: hello
BROADCAST TREE:

#include <stdio.h>
#define MAX 100
int main() {
    int g[MAX][MAX] = {0}, v[MAX] = {0}, q[MAX];
    int n, e, u, w, r, f = 0, b = 0;
    printf("Subnets/hosts: ");
    scanf("%d", &n);
    printf("Connections: ");
    scanf("%d", &e);
    for (int i = 0; i < e; i++) {
        printf("Edge (u w): ");
        scanf("%d %d", &u, &w);
        g[u][w] = g[w][u] = 1;
    }
    printf("Root: ");
    scanf("%d", &r);
    v[r] = 1;
    q[b++] = r;
    printf("\nBroadcast Tree:\n");
    while (f < b) {
        int x = q[f++];
        for (int i = 0; i < n; i++) {
            if (g[x][i] && !v[i]) {
                printf("%d -> %d\n", x, i);
                v[i] = 1;
                q[b++] = i;
            }
        }
    }
}
OUTPUT
Subnets/hosts: 5
Connections: 4
Edge (u v): 1 2
Edge (u v): 1 3
Edge (u v):  1 4
Edge (u v):  0 1
Root: 0
Broadcast Tree:
0 -> 1
1 -> 2
1 -> 3
1 -> 4 















Hamming code but works only for 4bits
 
#include <stdio.h>
int main() {
    int d3, d5, d6, d7, p1, p2, p4, e, parity;
    printf("Enter no. of data bits: 4\n");
    printf("Enter data bits (LSB first): ");  
    scanf("%d %d %d %d", &d3, &d5, &d6, &d7);
    printf("Choose parity (0 = even, 1 = odd): ");
    scanf("%d", &parity);
    p1 = (d3 + d5 + d7) % 2;
    p2 = (d3 + d6 + d7) % 2;
    p4 = (d5 + d6 + d7) % 2;
    if (parity) {
        p1 ^= 1;
        p2 ^= 1;
        p4 ^= 1;
    }
    printf("Hamming code: %d%d%d%d%d%d%d\n", p1, p2, d3, p4, d5, d6, d7);
    printf("Enter error position (0 for no error): ");
    scanf("%d", &e);
    if (e == 1) p1 ^= 1;
    if (e == 2) p2 ^= 1;
    if (e == 3) d3 ^= 1;
    if (e == 4) p4 ^= 1;
    if (e == 5) d5 ^= 1;
    if (e == 6) d6 ^= 1;
    if (e == 7) d7 ^= 1;
    printf("Code after error: %d%d%d%d%d%d%d\n", p1, p2, d3, p4, d5, d6, d7);
    int c1 = (p1 + d3 + d5 + d7) % 2;
    int c2 = (p2 + d3 + d6 + d7) % 2;
    int c4 = (p4 + d5 + d6 + d7) % 2;
    if (parity) {
        c1 ^= 1;
        c2 ^= 1;
        c4 ^= 1;
    }
    int pos = c4 * 4 + c2 * 2 + c1;
    if (pos == 0)
        printf("No error detected.\n");
    else {
        printf("Error detected at position: %d\n", pos);
        if (pos == 1) p1 ^= 1;
        if (pos == 2) p2 ^= 1;
        if (pos == 3) d3 ^= 1;
        if (pos == 4) p4 ^= 1;
        if (pos == 5) d5 ^= 1;
        if (pos == 6) d6 ^= 1;
        if (pos == 7) d7 ^= 1;
        printf("Corrected code: %d%d%d%d%d%d%d\n", p1, p2, d3, p4, d5, d6, d7);
    }
    return 0;
}


output

Enter 4 data bits (d3 d5 d6 d7): 1 0 1 0  
Choose parity (0 = even, 1 = odd): 0
Hamming code: 1011010
Enter error position (0 for no error): 1
Code after error: 0011010
Error detected at position: 1
Corrected code: 1011010
	












